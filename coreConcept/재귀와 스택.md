# 재귀와 스택

재귀 Recursion

: 큰 목표 작업 하나를 동일하면서 간단한 작업 여러 개로 나눌 수 있을 때 유용한 프로그래밍 패턴. 목표 작업을 간단한 동작 하나와 목표작업을 변형한 작업으로 단순화시킬 수 있을 때도 재귀 사용. 특정 자료 구조를 다루어야할 때 역시.

문제 해결을 하다 보면 함수에서 다른 함수를 호출해야할 때가 있는데, 이때 함수가 자기자신을 호출하면, 재귀!

# 두 가지 사고방식

> x를 n 제곱해주는 함수 pow(x, n)을 만들어보자

```
pow(2, 2) = 4
pow(2, 3) = 8
pow(2, 4) = 16
```

> 구현 방법 2가지

# 1. 반복문을 통한 방법: for 루프

```
function pow(x, n) {
let result = 1;//반복문을 돌면서 x를 n번 곱함
  for (let i = 9; i < n; i++) {
    result *= x;
  }
   return result;
}alert(pow(2, 3)); //8
```

# 2. 재귀를 통한 방법: 작업을 단순화하고 자기 자신을 호출함

```
function pow(x, n) {
//base case
  if *n === 1) {
    return x;
  }
//recursive case 
  else {
    return x * pow(x, n - 1);
  }
}
```

# 재귀와 반복문의 차이는?

```
            if (n === 1) return xpow(x, n) =            else return x * pow(x, n - 1)
```

1. n === 1일 때: 모든 절차가 간단해지고 명확한 결과값을 도출하므로 재귀의 베이스라고 한다. base case
2. n === 1가 아닐 때: pow(x, n)은 x * pow(x, n — 1)로 표현 가능. 이것이 재귀 단계. recursive case. 목표 작업 pow(x, n)을 간단한 동작 (x를 곱하기)과 목표 작업을 변형한 작업 pow(x, n -1)으로 분할. 재귀 단계는 n이 1이 될 때까지 계속 이어진다.

즉, pow는 n === 1이 될 때까지 재귀적으로 자신을 호출하는 것!

![Image for post](https://miro.medium.com/max/60/1*bn8DVkK9bj__WoaaRTJoKQ.png?q=20)

![Image for post](https://miro.medium.com/max/939/1*bn8DVkK9bj__WoaaRTJoKQ.png)

> 재귀를 이렇게 짧은 코드로도 쓸 수 있다!

```
function pow(x, n) {
  return (n === 1) ? x: (x * pow(x, n - 1));
}
```

# 재귀 깊이 recursion depth

: 가장 처음하는 호출을 포함한 중첩 호출의 최대 개수는 재귀 깊이 (recursion depth)라고 함. pow(x, n)의 재귀 깊이는 n이다.

자바스크립트 엔진은 최대 지귀 깊이를 제한. 만개 정도까지는 허용.엔진에 따라 더 깊이 허용하는 경우도 있지만…..

# 재귀의 장점

: 재귀를 사용하면 간결하고 유지보스가 쉬운 코드를 만들 수 있다.

# 재귀의 단점

: 자바스크립트 엔진의 재귀 깊이 제한. 메모리 리크

# 실행 컨텍스트와 스택

: 실제 재귀 호출이 어떻게 동작하는지 알기 위해 함수 내부 동작에 대해 알아본다.

실행 중인 함수의 실행 절차에 대한 정보는 해당 함수의 실행 컨텍스트 execution context에 저장된다.

실행 컨텍스트는 함수 실행에 대한 세부 정보를 담고 있는 **내부 데이터 구조**.

제어 흐름의 현재 위치, 변수의 현재 값, this의 값 등 상세 내부 정보가 실행 컨텍스트에 저장됨.

함수 호출 1회당 정확히 하나의 실행 컨텍스트가 생성된다.

함수 내부에 중첩 호출이 있을 때는 아래와 같은 절차가 수행된다.

- 현재 함수의 실행이 일시 중지됨
- 중지된 함수와 연관된 실행 컨텍스트는 **실행 컨텍스트 스택 execution context stack**이라는 특별한 자료 구조에 저장됨
- 중첩 호출이 실행됨
- 중첩 호출 실행이 끝난 이후 실행 컨텍스트 스택에서 일시 중단한 함수의 실행 컨텍스트를 꺼내오고, 중단한 함수의 실행을 다시 이어간다.

# pow(2, 3)이 호출되면 실행 컨텍스트에서는 무슨 일이?

# pow(2, 3)

pow(2, 3)을 호출하는 순간, 실행 컨텍스트에는 변수 x = 2, n = 3이 저장되고, 실행 흐름은 함수의 첫 번째 줄에 위치한다.

> Context: { x: 2, n: 3, 첫 번째 줄 } call: pow(2, 3)

위 그림은 함수 실행이 시작되는 순간을 나타낸 것!

지금 상태로는 조건 n ===1을 만족하지 못하므로 실행 흐름은 if의 두 번째 분기로 넘어간다.

```
function pow(x, n) {
  if (n === 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}alert(pow(2, 3));
```

변수는 동일하지만, 실행 흐름의 위치가 변경되면서 실행 컨텍스트도 다음과 같이 변경된다.

> Context: { x: 2, n: 3, 다섯 번째 줄 } call: pow(2, 3)

x * pow(x, n — 1)을 계산하려면 새로운 인수가 들어가는 **pow의 서브 호출 (subcall), pow(2, 2)**을 만들어야 한다.

# pow(2, 2)

**중첩 호출**을 하기 위해, 자바스크립트는 **실행 컨텍스트 스택**에 현재 실행 컨텍스트를 저장한다.

예시와 같이 실행 컨텍스트 스택에 동일한 함수 pow를 호출하였는데, 모든 함수에 대해 아래 프로세스가 똑같이 적용된다.

- 스택 최상단에 현재 컨텍스트가 ‘기록'된다.
- 서브 호출을 위한 새로운 컨텍스트가 만들어진다.
- 서브 호출이 완료되면 기존 컨텍스트를 스택에서 꺼내 (pop) 실행을 이어나간다.

서브 호출 pow(2, 2)이 시작될 때의 실행 컨텍스트 스택은 다음과 같다.

> **Context: { x: 2, n: 2, 첫 번째 줄 } call: pow(2, 2) — 새 실행 컨텍스트**
>
> Context: { x: 2, n: 3, 다섯 번째 줄 } call: pow(2, 3) — 기존 컨텍스트

이전 컨텍스트에 변수 정보, 코드가 일시 중단된 줄에 대한 정보가 저장되어 있기 때문에 서브 호출이 끝났을 때 이전 컨텍스트가 문제없이 다시 시작된다.

**다시말해, 실행이 ‘서브 호출 바로 직후'에 시작된다!**

# pow(2, 1)

동일한 과정이 다시 반복된다. 다섯 번째 주에서 인수 x = 2, n = 1과 함께 새로운 서브 호출이 만들어진다.

새로운 실행 컨텍스트가 만들어지고, 이전 실행 컨텍스트는 스택 최상단에 올라간다 (push)

> **Context: { x: 2, n: 1, 첫 번째 줄 } call: pow(2, 1)**
>
> Context: { x: 2, n: 2, 다섯 번째 줄 } call: pow(2, 2)
>
> Context: {x: 2, n: 3, 다섯 번째 줄 } call: pow(2, 3)

기존 컨텍스트 2개가 밑에, pow(2, 1)에 상응하는 컨텍스트가 맨 위에 있다!

# 실행 종료

pow(2, 1)이 실행될 때는 상황이 다름. 이전과는 달리 조건 n === 1을 만족시키므로, if문의 첫 번째 분기가 실행된다.

```
function pow(x, n) {
  if (n === 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}
```

이제는 호출해야할 중첩 호출이 없다. 따라서 함수는 종료되고 2가 반환된다.

함수가 종료되었기 때문에 이에 상응하는 실행 컨텍스트는 쓸모가 없어졌다. 따라서 해당 실행 컨텍스트는 메모리에서 삭제된다. 스택 맨 위에는 이전의 실행 컨텍스트가 위치한다.

> **Context: { x: 2, n: 2, 다섯 번째 줄 } call: pow(2, 2)**
>
> Context: { x: 2, n: 3, 다섯 번째 줄} call: pow(2, 3)

pow(2, 2)의 실행이 다시 시작된다. 서브 호출 pow(2, 1)의 결과를 알고 있으므로, 쉽게 x * pow(x, n-1)을 계산해 4를 반환한다.

그리고 다시 이전 컨텍스트가 스택 최상단에 위치하게 된다.

> **Context: {x: 2, n: 3, 다섯 번째 줄 } call: pow(2, 3)**

마지막 실행 컨텍스트까지 처리되면 pow(2, 3) = 8이라는 결과가 도출된다.

지금 본 예시의 재귀 깊이는 3이다.

재귀 깊이는 결국 스택에 들어가는 실행 컨텍스트 수의 최대값과 같다.

**실행 컨텍스트는 메모리를 차지하므로 재귀를 사용할 때는 메모리 요구사항에 유의**해야 한다. n을 늘리면 n이 줄어들 때마다 만들어지는 **n개의 실행 컨텍스트가 저장될 메모리 공간이 필요**하기 때문이다.

# 반복문의 장점

한편, 반복문 기반 알고리즘을 사용하면 메모리가 절약된다.

```
function pow(x, n) {
let result = 1;
for (let i = 0; i < n; i++) {
result *= x;
}
return result;
}
```

**반복문을 사용해 만든 함수 pow(x, n)는 컨텍스트를 하나만 사용한다.**

이 컨텍스트에서 i와 result가 변경된다. 실행 컨텍스트가 하나이기 때문에 n에 의존적이지 않고, 필요한 메모리가 적다. 사용 메모리 공간도 고정된다.

# 반복문과 재귀의 관계?

재귀를 이용해 작성한 코드는 반복문을 사용한 코드로 다시 작성 가능하다. 반복문을 사용하면 대개 함수 호출의 비용 (메모리 사용)이 절약된다.

모든 곳에서 메모리 최적화를 신경써야하는 것은 아니므로, 때에 따라 이해도가 높은 짧은 코드의 재귀를 사용하기도 한다.

# 특히, 재귀가 필요한 때? 재귀적 순회 recursive traversal

재귀적 순회를 구현할 때 재귀를 사용하면 좋다.

부모노드와 자식노드에 있어서의 깊이가 정해지지 않았을 때 반복문과 중첩 반복문을 사용하면 코드가 굉장히 복잡해진다. (하지만 메모리 소모를 방지하려면 반복문이 더 낫다!)

# 재귀적 구조

: 재귀적으로 정의된 자료 구조인 재귀적 자료 구조는 자기 자신의 일부를 복제하는 형태의 자료 구조이다.

예를 들어, 회사의 부서 객체는 두 가지 종류로 나뉜다.

- 사람들로 구성된 배열
- 하위 부서로 이루어진 객체

# 연결 리스트

객체를 정렬하여 어딘가에 저장하고 싶다고 가정해보자.

가장 먼저 떠오르는 자료 구조는: 배열

```
let arr = [obj1, obj2, obj3];
```

하지만 배열은 요소 ‘삭제'와 ‘삽입'에 들어가는 비용이 많이 든다는 문제가 있다.

arr.unshift(obj) 연산을 수행하려면 새로운 obj를 위한 공간을 만들기 위해 모든 요소의 번호를 다시 매겨야하기 때문이다. 배열이 커지면 연산 수행 시간이 더 걸리게 된다. arr.shift()를 사용할 때도 마찬가지!

요소 전체의 번호를 다시 매기지 않아도 되는 조작은 배열 끝에 하는 연산인 arr.push/pop 뿐이다. 앞쪽 요소에 무언가를 할 때 배열은 이처럼 꽤 느리다.

빠르게 삽입 호은 삭제를 해야할 때는 배열 대신 연결 리스트 (linked list)라는 자료 구조를 사용할 수 있다.

**연결리스트의 요소는 객체와 아래 프로퍼티들을 조합해 정의할 수 있다.**

- **value**
- **next: 다음 연결 리스트 요소를 참조하는 프로퍼티. 다음 요소가 없을 땐 null이 된다.**

```
let list = {
value: 1, 
next: {
value: 2,
next: {
value: 3,
next: {
value:4, 
next: null
}
}
}
};
```

![Image for post](https://miro.medium.com/max/60/1*4YoxxoxjrIn4SXps5k98bA.png?q=20)

![Image for post](https://miro.medium.com/max/841/1*4YoxxoxjrIn4SXps5k98bA.png)

아래처럼 코드를 작성해도 동일한 연결 리스트가 된다.

```
let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };
list.next.next.next.next = null;
```

이렇게 연결 리스트를 만드니 객체가 여러 개 있고, 각 객체엔 value와 이웃 객체를 가리키는 프로퍼티인 next가 있는 것이 명확히 보인다. 체인의 시작 객체는 변수 list에 저장되어 있다. 우리는 list의 next 프로퍼티를 이용해 이어지는 객체 어디든 도달하 수 있다.

연결 리스트를 사용하면 전체 리스트를 여러 부분으로 쉽게 나눌 수 있고 다시 합치는 것도 가능하다.

```
let secondList = list.next.next;
list.next.next = null;
```

![Image for post](https://miro.medium.com/max/60/1*nc3Aru0MxGxsjamh-S1Rkg.png?q=20)

![Image for post](https://miro.medium.com/max/541/1*nc3Aru0MxGxsjamh-S1Rkg.png)

합치기:

```
list.next.next = secondList;
```

그리고 쉽게 요소를 추가하거나 삭제할 수 있다.

리스트의 처음 객체를 바꾸면 리스트 맨 앞에 새로운 값을 추가할 수 있다.

```
let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };//list에 새로운 value를 추가한다.
list = { value: "new item", next: list };
```

![Image for post](https://miro.medium.com/max/60/1*IMnASgfWK803wixLOgz_VQ.png?q=20)

![Image for post](https://miro.medium.com/max/1019/1*IMnASgfWK803wixLOgz_VQ.png)

중간 요소를 제거하려면 이전 요소의 next를 변경해주면 된다.

```
list.next = list.next.next;
```

![Image for post](https://miro.medium.com/max/60/1*pl5y5H4GgnuZEdY7PpKi9Q.png?q=20)

![Image for post](https://miro.medium.com/max/841/1*pl5y5H4GgnuZEdY7PpKi9Q.png)

list.next가 1이 아닌 2를 value로 갖는 객체를 가리키게 만들었다. 이제 value 1은 체인에서 제외된다. 이 객체는 다른 곳에 따로 저장하지 않으면 자동으로 메모리에서 제거된다.

# 연결 리스트 장점

이렇게 연결 리스트는 배열과는 달리 대량으로 요소 번호를 재할당하지 않으므로 요소를 쉽게 재배열할 수 있다.

# 연결 리스트 단점

번호(인덱스)만 사용해 요소에 접근할 수 없다는 점. 배열을 사용하면 arr[i]처럼 번호 i만으로도 원하는 요소에 바로 접근할 수 있지만 연결 리스트에서는 i번째 값을 얻기 위해 첫 번째 항목부터 시작해 i번 next로 이동해야 한다.

그런데 중간에 요소를 삽입하거나 삭제하는 연산이 항상 필요한 것은 아니므로 이럴 때는 순서가 있는 자료형 중에 큐 queue나 데크 deque를 사용하면 된다. 데크를 사용하면 양 끝에서 삽입과 삭제를 빠르게 수행할 수 있다.

위에서 구현한 연결 리스트는 아래와 같은 기능을 더해 개선할 수 있다.

- 이전 요소를 참조하는 프로퍼티 prev를 추가해 이전 요소로 쉽게 이동가능
- 리스트의 마지막 요소를 참조하는 변수 tail을 추가할 수 있다. 다만 리스트 마지막에 요소를 추가하거나 삭제할 때 tail도 갱신해주어야 한다.
- 이외에도 요구사항에 따라 구조 변경 가능